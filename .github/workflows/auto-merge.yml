name: Auto-merge PRs

on:
  # Fallback sweep - catches PRs missed by the primary merge in pr-validate.yml
  schedule:
    - cron: '*/30 * * * *'
  # Trigger when builder or other check suites complete
  check_suite:
    types: [completed]
  # Allow manual trigger
  workflow_dispatch:

permissions:
  contents: write
  pull-requests: write
  checks: read
  actions: read

jobs:
  auto-merge:
    name: Auto-merge eligible PRs
    runs-on: ubuntu-latest
    steps:
      - name: Find and merge eligible PRs
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            // List all open PRs with the 'automated' label
            const { data: prs } = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              sort: 'created',
              direction: 'asc'
            });

            const automatedPrs = prs.filter(pr =>
              pr.user.login === 'github-actions[bot]' &&
              !pr.draft &&
              pr.labels.some(l => l.name === 'automated')
            );

            if (automatedPrs.length === 0) {
              console.log('No eligible automated PRs found');
              return;
            }

            console.log(`Found ${automatedPrs.length} automated PR(s) to evaluate`);

            const blockingLabels = ['do-not-merge', 'needs-review', 'on-hold'];

            for (const pr of automatedPrs) {
              console.log(`\n--- Evaluating PR #${pr.number}: ${pr.title} ---`);

              const labels = pr.labels.map(l => l.name);

              // Check for validation-passed label
              if (!labels.includes('validation-passed')) {
                console.log(`PR #${pr.number}: Missing "validation-passed" label, skipping`);
                continue;
              }

              // Check for blocking labels
              const hasBlockingLabel = labels.some(l => blockingLabels.includes(l));
              if (hasBlockingLabel) {
                const found = labels.filter(l => blockingLabels.includes(l));
                console.log(`PR #${pr.number}: Has blocking label(s): ${found.join(', ')}, skipping`);
                continue;
              }

              // Check all check runs (Builder + PR Validation)
              const { data: checkRuns } = await github.rest.checks.listForRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: pr.head.sha,
                filter: 'latest'
              });

              const relevantRuns = checkRuns.check_runs.filter(cr =>
                cr.name.startsWith('Build ') ||
                cr.name === 'Initialize build' ||
                cr.name === 'Validate Repository Structure' ||
                cr.name === 'Validate CHANGELOG Updates' ||
                cr.name === 'Lint YAML Files' ||
                cr.name === 'Validation Summary'
              );

              if (relevantRuns.length === 0) {
                console.log(`PR #${pr.number}: No check runs found yet, skipping`);
                continue;
              }

              const incomplete = relevantRuns.filter(cr => cr.status !== 'completed');
              if (incomplete.length > 0) {
                console.log(`PR #${pr.number}: ${incomplete.length} check(s) still running, skipping`);
                continue;
              }

              const failed = relevantRuns.filter(cr => cr.conclusion !== 'success');
              if (failed.length > 0) {
                console.log(`PR #${pr.number}: ${failed.length} check(s) failed:`);
                failed.forEach(cr => console.log(`  - ${cr.name}: ${cr.conclusion}`));
                continue;
              }

              console.log(`PR #${pr.number}: All ${relevantRuns.length} checks passed`);

              // Re-fetch PR for mergeability status
              let mergeablePr;
              for (let attempt = 1; attempt <= 3; attempt++) {
                const { data: freshPr } = await github.rest.pulls.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: pr.number
                });
                mergeablePr = freshPr;
                if (mergeablePr.mergeable !== null) break;
                console.log(`PR #${pr.number}: Waiting for mergeability (attempt ${attempt}/3)...`);
                await new Promise(resolve => setTimeout(resolve, 5000));
              }

              if (!mergeablePr.mergeable) {
                console.log(`PR #${pr.number}: Not mergeable (state: ${mergeablePr.mergeable_state}), skipping`);
                continue;
              }

              // All conditions met - merge
              console.log(`PR #${pr.number}: All conditions met - merging`);
              try {
                await github.rest.pulls.merge({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: pr.number,
                  merge_method: 'squash',
                  commit_title: pr.title,
                  commit_message: `${pr.body || ''}\n\nAuto-merged by GitHub Actions`
                });

                console.log(`PR #${pr.number}: Merged successfully`);

                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: pr.number,
                  body: 'âœ… All validation and build checks passed. PR has been automatically merged (via scheduled sweep).'
                });
              } catch (error) {
                console.log(`PR #${pr.number}: Merge failed: ${error.message}`);
              }
            }
