name: Auto-merge PRs

on:
  pull_request:
    types: [labeled, synchronize]
  workflow_run:
    workflows: ["PR Validation"]
    types: [completed]

permissions:
  contents: write
  pull-requests: write

jobs:
  auto-merge:
    name: Auto-merge PR
    runs-on: ubuntu-latest
    # Only run on workflow_run events or when validation-passed label is added
    if: |
      (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success') ||
      (github.event_name == 'pull_request' && github.event.action == 'labeled' && github.event.label.name == 'validation-passed')
    steps:
      - name: Get PR number
        id: pr
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            let prNumber;

            if (context.eventName === 'workflow_run') {
              // Get PR from workflow run
              const { data: prs } = await github.rest.pulls.list({
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'open',
                head: `${context.repo.owner}:${context.payload.workflow_run.head_branch}`
              });

              if (prs.length === 0) {
                console.log('No open PR found for this workflow run');
                return;
              }
              prNumber = prs[0].number;
            } else {
              prNumber = context.issue.number;
            }

            console.log(`PR number: ${prNumber}`);
            core.setOutput('number', prNumber);

      - name: Check PR conditions and merge
        if: steps.pr.outputs.number
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const prNumber = ${{ steps.pr.outputs.number }};

            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });

            console.log('PR Details:', {
              number: pr.number,
              state: pr.state,
              draft: pr.draft,
              mergeable: pr.mergeable,
              mergeable_state: pr.mergeable_state,
              user: pr.user.login
            });

            // Only auto-merge PRs from github-actions bot
            if (pr.user.login !== 'github-actions[bot]') {
              console.log('PR not created by github-actions[bot], skipping auto-merge');
              return;
            }

            // Check if PR is ready
            if (pr.state !== 'open') {
              console.log('PR is not open');
              return;
            }

            if (pr.draft) {
              console.log('PR is a draft');
              return;
            }

            // Check for required labels
            const labels = pr.labels.map(l => l.name);
            console.log('Labels:', labels);

            if (!labels.includes('automated')) {
              console.log('Missing "automated" label');
              return;
            }

            if (!labels.includes('validation-passed')) {
              console.log('Missing "validation-passed" label - waiting for validation');
              return;
            }

            // Check if any blocking labels are present
            const blockingLabels = ['do-not-merge', 'needs-review', 'on-hold'];
            const hasBlockingLabel = labels.some(l => blockingLabels.includes(l));
            if (hasBlockingLabel) {
              console.log('PR has blocking label');
              return;
            }

            // Wait a moment for GitHub to calculate mergeability
            if (pr.mergeable === null) {
              console.log('Waiting for mergeability check...');
              await new Promise(resolve => setTimeout(resolve, 5000));

              // Re-fetch PR
              const { data: refreshedPr } = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber
              });

              if (!refreshedPr.mergeable) {
                console.log('PR is not mergeable:', refreshedPr.mergeable_state);
                return;
              }
            } else if (!pr.mergeable) {
              console.log('PR is not mergeable:', pr.mergeable_state);
              return;
            }

            // All conditions met - merge the PR
            console.log('All conditions met - merging PR');

            try {
              await github.rest.pulls.merge({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber,
                merge_method: 'squash',
                commit_title: pr.title,
                commit_message: `${pr.body || ''}\n\nAuto-merged by GitHub Actions`
              });

              console.log('PR merged successfully');

              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: '✅ All validation checks passed. PR has been automatically merged.'
              });
            } catch (error) {
              console.log('Merge failed:', error.message);

              // Comment about the failure
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: `⚠️ Auto-merge failed: ${error.message}\n\nPlease merge manually if appropriate.`
              });
            }
