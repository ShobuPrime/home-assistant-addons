name: PR Validation

on:
  pull_request:
    types: [opened, synchronize, reopened]
  repository_dispatch:
    types: [automated-pr-created]

permissions:
  contents: write
  pull-requests: write
  checks: write
  actions: read

jobs:
  resolve-context:
    name: Resolve PR context
    runs-on: ubuntu-latest
    outputs:
      pr_number: ${{ steps.context.outputs.pr_number }}
      head_sha: ${{ steps.context.outputs.head_sha }}
      base_ref: ${{ steps.context.outputs.base_ref }}
    steps:
      - name: Resolve context from event
        id: context
        run: |
          if [ "${{ github.event_name }}" = "repository_dispatch" ]; then
            echo "pr_number=${{ github.event.client_payload.pull_request_number }}" >> $GITHUB_OUTPUT
            echo "head_sha=${{ github.event.client_payload.head_sha }}" >> $GITHUB_OUTPUT
            echo "base_ref=master" >> $GITHUB_OUTPUT
          else
            echo "pr_number=${{ github.event.pull_request.number }}" >> $GITHUB_OUTPUT
            echo "head_sha=${{ github.event.pull_request.head.sha }}" >> $GITHUB_OUTPUT
            echo "base_ref=${{ github.base_ref }}" >> $GITHUB_OUTPUT
          fi

  validate-structure:
    name: Validate Repository Structure
    runs-on: ubuntu-latest
    needs: resolve-context
    steps:
      - name: Checkout PR branch
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.resolve-context.outputs.head_sha }}

      - name: Validate addon structure
        id: validate
        run: |
          EXIT_CODE=0
          ERRORS=""

          # Find all addon directories (those with config.yaml)
          for addon_dir in */config.yaml; do
            addon_dir=$(dirname "$addon_dir")
            echo "Validating $addon_dir..."

            # Check required files
            for required_file in config.yaml Dockerfile README.md DOCS.md CHANGELOG.md; do
              if [ ! -f "$addon_dir/$required_file" ]; then
                ERRORS="${ERRORS}\n- Missing $required_file in $addon_dir"
                EXIT_CODE=1
              fi
            done

            # Validate config.yaml structure
            if [ -f "$addon_dir/config.yaml" ]; then
              # Check for required fields
              for field in name version slug description arch; do
                if ! grep -q "^${field}:" "$addon_dir/config.yaml"; then
                  ERRORS="${ERRORS}\n- Missing required field '$field' in $addon_dir/config.yaml"
                  EXIT_CODE=1
                fi
              done

              # Extract version for validation
              VERSION=$(grep "^version:" "$addon_dir/config.yaml" | sed 's/version: *"\(.*\)"/\1/')

              # Validate version format (semver)
              if ! echo "$VERSION" | grep -qE '^[0-9]+\.[0-9]+\.[0-9]+$'; then
                ERRORS="${ERRORS}\n- Invalid version format in $addon_dir/config.yaml: $VERSION (should be X.Y.Z)"
                EXIT_CODE=1
              fi
            fi

            # Validate Dockerfile
            if [ -f "$addon_dir/Dockerfile" ]; then
              # Check for FROM instruction
              if ! grep -q "^FROM" "$addon_dir/Dockerfile"; then
                ERRORS="${ERRORS}\n- Missing FROM instruction in $addon_dir/Dockerfile"
                EXIT_CODE=1
              fi
            fi
          done

          if [ $EXIT_CODE -eq 0 ]; then
            echo "✓ All structure validations passed"
          else
            echo -e "✗ Validation errors:${ERRORS}"
          fi

          # Save errors for comment
          echo "ERRORS<<EOF" >> $GITHUB_OUTPUT
          echo -e "$ERRORS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          exit $EXIT_CODE

      - name: Comment validation results
        if: failure()
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const errors = `${{ steps.validate.outputs.ERRORS }}`;
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: ${{ needs.resolve-context.outputs.pr_number }},
              body: `## ❌ Repository Structure Validation Failed\n\n${errors}\n\nPlease fix these issues before merging.`
            });

  validate-changelog:
    name: Validate CHANGELOG Updates
    runs-on: ubuntu-latest
    needs: resolve-context
    steps:
      - name: Checkout PR branch
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.resolve-context.outputs.head_sha }}
          fetch-depth: 0

      - name: Check CHANGELOG updates
        id: check
        run: |
          # Get list of changed files
          BASE_REF="${{ needs.resolve-context.outputs.base_ref }}"
          git fetch origin "${BASE_REF}"
          CHANGED_FILES=$(git diff --name-only "origin/${BASE_REF}...HEAD")

          EXIT_CODE=0
          WARNINGS=""

          # Check if any addon files were modified
          for addon_dir in */config.yaml; do
            addon_dir=$(dirname "$addon_dir")

            # Check if addon files were modified
            if echo "$CHANGED_FILES" | grep -q "^${addon_dir}/"; then
              # Check if CHANGELOG was updated
              if ! echo "$CHANGED_FILES" | grep -q "^${addon_dir}/CHANGELOG.md"; then
                WARNINGS="${WARNINGS}\n- $addon_dir modified but CHANGELOG.md not updated"
              else
                # Verify CHANGELOG has content for this version
                # Support both "## Version X.Y.Z" and "## [X.Y.Z]" formats
                VERSION=$(grep "^version:" "$addon_dir/config.yaml" | sed 's/version: *"\(.*\)"/\1/')
                if ! grep -qE "## (Version )?(\[)?${VERSION}(\])?" "$addon_dir/CHANGELOG.md"; then
                  WARNINGS="${WARNINGS}\n- $addon_dir/CHANGELOG.md missing entry for version $VERSION"
                  EXIT_CODE=1
                fi
              fi
            fi
          done

          if [ -n "$WARNINGS" ]; then
            echo -e "⚠ Changelog warnings:${WARNINGS}"
            echo "WARNINGS<<EOF" >> $GITHUB_OUTPUT
            echo -e "$WARNINGS" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          else
            echo "✓ All CHANGELOG validations passed"
          fi

          exit $EXIT_CODE

      - name: Comment changelog warnings
        if: failure() || steps.check.outputs.WARNINGS != ''
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const warnings = `${{ steps.check.outputs.WARNINGS }}`;
            if (warnings) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: ${{ needs.resolve-context.outputs.pr_number }},
                body: `## ⚠️ CHANGELOG Validation Warnings\n\n${warnings}\n\nPlease ensure all changes are documented in CHANGELOG.md.`
              });
            }

  lint-yaml:
    name: Lint YAML Files
    runs-on: ubuntu-latest
    needs: resolve-context
    steps:
      - name: Checkout PR branch
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.resolve-context.outputs.head_sha }}

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'

      - name: Install yamllint
        run: pip install yamllint

      - name: Lint YAML files
        run: |
          # Create yamllint config
          cat > .yamllint << 'EOF'
          extends: default
          rules:
            line-length:
              max: 120
              level: warning
            document-start: disable
            truthy:
              allowed-values: ['true', 'false', 'yes', 'no']
            empty-lines:
              max: 1
              max-end: 1
            new-line-at-end-of-file: disable
          EOF

          # Lint all YAML files
          yamllint -f parsable $(find . -name "*.yaml" -o -name "*.yml" | grep -v ".git")

  summary:
    name: Validation Summary
    runs-on: ubuntu-latest
    needs: [resolve-context, validate-structure, validate-changelog, lint-yaml]
    if: always()
    steps:
      - name: Check validation results
        id: results
        run: |
          FAILED=false

          if [ "${{ needs.validate-structure.result }}" != "success" ]; then
            echo "❌ Structure validation failed"
            FAILED=true
          fi
          if [ "${{ needs.validate-changelog.result }}" != "success" ]; then
            echo "❌ Changelog validation failed"
            FAILED=true
          fi
          if [ "${{ needs.lint-yaml.result }}" != "success" ]; then
            echo "❌ YAML linting failed"
            FAILED=true
          fi

          if [ "$FAILED" = "true" ]; then
            echo "passed=false" >> $GITHUB_OUTPUT
            exit 1
          fi

          echo "✅ All validations passed!"
          echo "passed=true" >> $GITHUB_OUTPUT

      - name: Add success label
        if: steps.results.outputs.passed == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const prNumber = ${{ needs.resolve-context.outputs.pr_number }};

            // Remove validation-passed label if it exists (to re-add fresh)
            try {
              await github.rest.issues.removeLabel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                name: 'validation-passed'
              });
            } catch (e) {
              // Label might not exist, that's fine
            }

            // Add the label
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              labels: ['validation-passed']
            });

            console.log('Added validation-passed label');

      - name: Remove success label on failure
        if: steps.results.outputs.passed != 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            try {
              await github.rest.issues.removeLabel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: ${{ needs.resolve-context.outputs.pr_number }},
                name: 'validation-passed'
              });
              console.log('Removed validation-passed label');
            } catch (e) {
              // Label might not exist, that's fine
              console.log('validation-passed label not present');
            }

  auto-merge:
    name: Auto-merge if eligible
    runs-on: ubuntu-latest
    needs: [resolve-context, validate-structure, validate-changelog, lint-yaml, summary]
    if: |
      always() &&
      needs.validate-structure.result == 'success' &&
      needs.validate-changelog.result == 'success' &&
      needs.lint-yaml.result == 'success' &&
      needs.summary.result == 'success'
    steps:
      - name: Check conditions and merge
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const prNumber = ${{ needs.resolve-context.outputs.pr_number }};
            const headSha = '${{ needs.resolve-context.outputs.head_sha }}';

            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });

            console.log('PR Details:', {
              number: pr.number,
              state: pr.state,
              draft: pr.draft,
              mergeable: pr.mergeable,
              mergeable_state: pr.mergeable_state,
              user: pr.user.login
            });

            // Only auto-merge PRs from github-actions bot
            if (pr.user.login !== 'github-actions[bot]') {
              console.log('PR not created by github-actions[bot], skipping auto-merge');
              return;
            }

            if (pr.state !== 'open' || pr.draft) {
              console.log('PR is not open or is a draft');
              return;
            }

            // Check for required labels
            const labels = pr.labels.map(l => l.name);
            console.log('Labels:', labels);

            if (!labels.includes('automated')) {
              console.log('Missing "automated" label');
              return;
            }

            // Check for blocking labels
            const blockingLabels = ['do-not-merge', 'needs-review', 'on-hold'];
            const hasBlockingLabel = labels.some(l => blockingLabels.includes(l));
            if (hasBlockingLabel) {
              const found = labels.filter(l => blockingLabels.includes(l));
              console.log('PR has blocking label(s):', found);
              return;
            }

            // Wait for Builder workflow to complete
            console.log('Checking Builder workflow status...');
            const maxAttempts = 30;
            const pollInterval = 20000; // 20 seconds

            for (let attempt = 1; attempt <= maxAttempts; attempt++) {
              const { data: checkRuns } = await github.rest.checks.listForRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: headSha,
                filter: 'latest'
              });

              // Find Builder check runs (build jobs from builder.yml)
              const builderRuns = checkRuns.check_runs.filter(cr =>
                cr.name.startsWith('Build ') || cr.name === 'Initialize build'
              );

              if (builderRuns.length === 0) {
                console.log(`Attempt ${attempt}/${maxAttempts}: No Builder checks found yet, waiting...`);
                if (attempt < maxAttempts) {
                  await new Promise(resolve => setTimeout(resolve, pollInterval));
                  continue;
                }
                console.log('Builder workflow never appeared - skipping merge (fallback sweep will retry)');
                return;
              }

              const allComplete = builderRuns.every(cr => cr.status === 'completed');
              const allSuccess = builderRuns.every(cr => cr.conclusion === 'success');

              if (!allComplete) {
                console.log(`Attempt ${attempt}/${maxAttempts}: Builder still running (${builderRuns.filter(cr => cr.status === 'completed').length}/${builderRuns.length} complete)`);
                if (attempt < maxAttempts) {
                  await new Promise(resolve => setTimeout(resolve, pollInterval));
                  continue;
                }
                console.log('Builder did not complete in time - fallback sweep will retry');
                return;
              }

              if (!allSuccess) {
                const failed = builderRuns.filter(cr => cr.conclusion !== 'success');
                console.log('Builder checks failed:', failed.map(cr => `${cr.name}: ${cr.conclusion}`));
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  body: `⚠️ Auto-merge skipped: Builder workflow failed.\n\nFailed checks:\n${failed.map(cr => `- **${cr.name}**: ${cr.conclusion}`).join('\n')}\n\nPlease investigate and merge manually if appropriate.`
                });
                return;
              }

              console.log('All Builder checks passed');
              break;
            }

            // Wait for GitHub to finalize mergeability
            let mergeablePr = pr;
            for (let attempt = 1; attempt <= 6; attempt++) {
              if (mergeablePr.mergeable !== null) break;
              console.log(`Waiting for mergeability calculation (attempt ${attempt}/6)...`);
              await new Promise(resolve => setTimeout(resolve, 5000));
              const { data: refreshed } = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber
              });
              mergeablePr = refreshed;
            }

            if (!mergeablePr.mergeable) {
              console.log('PR is not mergeable:', mergeablePr.mergeable_state);
              return;
            }

            // All conditions met - merge
            console.log('All conditions met - merging PR');
            try {
              await github.rest.pulls.merge({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber,
                merge_method: 'squash',
                commit_title: pr.title,
                commit_message: `${pr.body || ''}\n\nAuto-merged by GitHub Actions`
              });

              console.log('PR merged successfully');

              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: '✅ All validation and build checks passed. PR has been automatically merged.'
              });
            } catch (error) {
              console.log('Merge failed:', error.message);
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: `⚠️ Auto-merge failed: ${error.message}\n\nThe scheduled fallback sweep will retry, or merge manually if appropriate.`
              });
            }
